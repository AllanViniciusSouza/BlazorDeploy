<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Rota019</title>
    <base href="/" />

    <!-- ✅ Bootstrap via CDN (sem arquivos locais) -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Seu CSS e manifestos -->
    <link href="css/app.css" rel="stylesheet" />
    <link href="BlazorDeploy.styles.css" rel="stylesheet" />
    <link rel="icon" type="image/png" href="logo.png" />
    <link rel="manifest" href="manifest.webmanifest" />
    <link rel="apple-touch-icon" sizes="512x512" href="logo.png" />
    <link rel="apple-touch-icon" sizes="192x192" href="logo.png" />

    <!-- Google Places API (mantido, caso ainda use) -->
    <script async src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBy_9neF5tiB38rjc9FiZjbP7H13JS-OZI&libraries=places&v=weekly&region=BR&language=pt-BR&components=element"></script>
    <script type="module" src="https://unpkg.com/@googlemaps/places-widget-element/dist/places-widget-element.js"></script>
    <script src="js/autocomplete.js"></script>
    <script src="js/triggerFileInput.js"></script>
    <script src="js/barcodeScanner.js"></script>


</head>


<body>
    <div id="app">
        <svg class="loading-progress">
            <circle r="40%" cx="50%" cy="50%" />
            <circle r="40%" cx="50%" cy="50%" />
        </svg>
        <div class="loading-progress-text"></div>
    </div>
    <script src="_framework/blazor.webassembly.js"></script>

    <script>
        // keyHandler: expose F1 handler that calls .NET OnF1Key via DotNetObjectReference
        (function () {
            var dotNetRefF1 = null;
            function f1Handler(e) {
                try {
                    if (e.key === 'F1') {
                        e.preventDefault();
                        if (dotNetRefF1) {
                            try { dotNetRefF1.invokeMethodAsync('OnF1Key'); } catch (ex) { }
                        }
                    }
                } catch (ex) { }
            }

            window.keyHandler = {
                addF1Handler: function (dref) {
                    try {
                        dotNetRefF1 = dref;
                        window.addEventListener('keydown', f1Handler);
                    } catch (e) { }
                },
                removeF1Handler: function () {
                    try {
                        window.removeEventListener('keydown', f1Handler);
                        dotNetRefF1 = null;
                    } catch (e) { }
                }
            };
        })();

        // Global ESC handler registration for Blazor pages
        (function () {
            var dotRef = null;
            function onKeyDown(e) {
                try {
                    // Always handle Escape: hide numeric keypad and notify .NET
                    if (e.key === 'Escape') {
                        try { if (window.numericKeypad && typeof window.numericKeypad.hide === 'function') window.numericKeypad.hide(); } catch (ex) { }
                        if (dotRef) {
                            try { dotRef.invokeMethodAsync('OnEscapePressed'); } catch { }
                        }
                        return;
                    }
                } catch (ex) { }

                try {
                    // ignore other keys when typing in inputs/textareas/selects
                    var tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toUpperCase() : '';
                    if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || tag === 'OPTION') return;
                } catch (ex) { }

                // detect plus: main keyboard '+' (Shift+'='), Numpad add
                var isPlus = false;
                try {
                    if (e.key === '+') isPlus = true;
                    if (e.code === 'NumpadAdd') isPlus = true;
                    if (e.key === 'Add') isPlus = true;
                    if (e.key === '=' && e.shiftKey) isPlus = true;
                } catch (ex) { }

                if (isPlus && dotRef) {
                    try { dotRef.invokeMethodAsync('OnPlusPressed'); } catch { }
                }
            }
            window.addGlobalEscHandler = function (dref) {
                try {
                    dotRef = dref;
                    window.addEventListener('keydown', onKeyDown);
                } catch { }
            };
            window.removeGlobalEscHandler = function () {
                try {
                    window.removeEventListener('keydown', onKeyDown);
                    dotRef = null;
                } catch { }
            };
        // helper to focus the last blank descricao textarea (prefer the most recently added)
        window.focusFirstBlankDescricao = function () {
            try {
                var els = document.querySelectorAll("textarea[placeholder='Descrição']");
                if (els && els.length) {
                    var el = els[els.length - 1];
                    el.focus();
                    try { el.scrollIntoView({ block: 'center', behavior: 'smooth' }); } catch (e) { }
                }
            } catch (e) { }
        };
        })();

        window.numericKeypad = {
            _target: null,
            show: function (elementId) {
                var keypad = document.getElementById('numeric-keypad');
                if (!keypad) return;
                var el = document.getElementById(elementId);
                if (!el) {
                    keypad.style.display = 'block';
                    this._target = elementId;
                    return;
                }
                // position keypad near the input
                keypad.style.display = 'block';
                keypad.style.right = '';
                keypad.style.bottom = '';
                var rect = el.getBoundingClientRect();
                var kpRect = keypad.getBoundingClientRect();
                var top = rect.top + window.scrollY - kpRect.height - 8; // above
                if (top < 8) top = rect.bottom + window.scrollY + 8; // below if not enough space
                var left = rect.left + window.scrollX;
                // keep inside viewport
                if (left + kpRect.width > window.innerWidth - 8) left = window.innerWidth - kpRect.width - 8;
                if (left < 8) left = 8;
                keypad.style.position = 'absolute';
                keypad.style.left = left + 'px';
                keypad.style.top = top + 'px';
                this._target = elementId;
            },
            hide: function () {
                var keypad = document.getElementById('numeric-keypad');
                if (!keypad) return;
                keypad.style.display = 'none';
                this._target = null;
                // reset to fixed defaults
                keypad.style.position = 'fixed';
                keypad.style.left = '';
                keypad.style.top = '';
            },
            _setCaret: function (el, pos) {
                try {
                    if (el.setSelectionRange) {
                        el.setSelectionRange(pos, pos);
                    }
                } catch (e) { }
            },
            insert: function (elementId, ch) {
                try {
                    ch = String(ch);
                    var targetId = elementId || this._target;
                    var el = document.getElementById(targetId);
                    if (!el) return;
                    el.focus();
                    console.log('numericKeypad.insert -> target=', elementId, 'ch=', ch, 'valueBefore=', el.value);
                    // insert at caret; prefer setRangeText when available
                    var start = (typeof el.selectionStart === 'number') ? el.selectionStart : null;
                    var end = (typeof el.selectionEnd === 'number') ? el.selectionEnd : null;
                    var origType = el.type;
                    try {
                        if (origType === 'number') el.type = 'text';
                        if (typeof el.setRangeText === 'function' && start !== null && end !== null) {
                            // modern browsers: use setRangeText to insert correctly
                            el.setRangeText(ch, start, end, 'end');
                            var newPos = (start + ch.length);
                            this._setCaret(el, newPos);
                        } else {
                        var val = el.value || '';
                        if (start === null || end === null) {
                            // fallback: append
                            el.value = val + ch;
                        } else {
                            el.value = val.substring(0, start) + ch + val.substring(end);
                        }
                        }
                    } finally {
                        try { if (origType === 'number') el.type = origType; } catch (e) { }
                    }
                    // dispatch input to ensure Blazor bindings pick up the new value
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    console.log('numericKeypad.insert -> valueAfter=', el.value);
                } catch (e) {
                    console.error('numericKeypad.insert error', e);
                }
            },
            backspace: function (elementId) {
                try {
                    var targetId = elementId || this._target;
                    var el = document.getElementById(targetId);
                    if (!el) return;
                    el.focus();
                    console.log('numericKeypad.backspace -> target=', elementId, 'valueBefore=', el.value);
                    var start = (typeof el.selectionStart === 'number') ? el.selectionStart : null;
                    var end = (typeof el.selectionEnd === 'number') ? el.selectionEnd : null;
                    var val = el.value || '';
                    var origType = el.type;
                    try {
                        if (origType === 'number') el.type = 'text';
                        if (typeof el.setRangeText === 'function' && start !== null && end !== null) {
                            if (start === end && start > 0) {
                                // delete previous char
                                el.setRangeText('', start - 1, end, 'end');
                                this._setCaret(el, start - 1);
                            } else if (start !== end) {
                                el.setRangeText('', start, end, 'end');
                                this._setCaret(el, start);
                            }
                        } else {
                        if (start === null || end === null) {
                            // fallback: remove last char
                            if (val.length > 0) el.value = val.slice(0, -1);
                        } else {
                            if (start === end && start > 0) {
                                el.value = val.substring(0, start - 1) + val.substring(end);
                                this._setCaret(el, start - 1);
                            } else if (start !== end) {
                                el.value = val.substring(0, start) + val.substring(end);
                                this._setCaret(el, start);
                            }
                        }
                        }
                    } finally {
                        try { if (origType === 'number') el.type = origType; } catch (e) { }
                    }
                    el.dispatchEvent(new Event('input', { bubbles: true }));
                    console.log('numericKeypad.backspace -> valueAfter=', el.value);
                } catch (e) {
                    console.error('numericKeypad.backspace error', e);
                }
            },
            commit: function (elementId) {
                var targetId = elementId || this._target;
                var el = document.getElementById(targetId);
                if (!el) return;
                // commit should trigger change so two-way bindings that listen on change update
                el.dispatchEvent(new Event('change', { bubbles: true }));
            }
        };
    </script>

    <script>navigator.serviceWorker.register('service-worker.js');</script>
</body>

</html>
